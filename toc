Table of content
================

Ideas:
    - Literate programming
    - Analyse de complexité au fur et à mesure
    - Comparaison des implémentations

______________________________________________________________________________


                                    ~~~

                        UNDERSTANDING RANDOM FORESTS

                                    ~~~


Part I: Growing random forests
==============================

1. Background                                                             12/01
-------------

* (Introduction)
* Machine learning
    > Data
    > Estimators
        - Classifiers
        - Regressors
    > API
* Goals and purposes


2. Classification and regression trees                                    02/02
--------------------------------------

* Tree structured estimators
    > (Titanic classification problem)
    > Estimators as partitions
    > Data structures (arrays vs. object-oriented structures)
    > (Mention multi-output)
* Growing decision trees
    > Recursive partition
        [ max_depth, max_leaf_nodes, min_samples_split, min_samples_leaf ]
        - Critères d'arrêt
        - Depth/Breadth/Best first
    > Splitting nodes
        [ max_features, min_samples_leaf ]
        - Best splits
            + Greedy approximation of optimal trees
            + How to evaluate multiple candidate thresholds cheaply for
              a given feature
            + Sorting algorithms
        - Weak learners (different from axis-aligned splits)
    > Impurity criteria
        - Efficient implementation for iterative evaluation
        - Effet du critère sur les cuts
        - Sample weighting
* Predicting
    > Procedure
    > Consistency


3. Forests of decision trees                                              16/02
----------------------------

* Bias-variance tradeoff
* Randomization
    > Subsampling (with/without replacement)
    > Splitting nodes
        - Best splits (among max_features)
        - Approximately best splits
            + Binning
            + Subsampling
        - Random splits
* Shared computations
    > Splitters
        - (Independent splitters)
        - Pre-sorting + data reorganization (Breiman's strategy)
        - Pre-sorting + sample_mask
    > Multi-threading


4. Complexity analysis                                                    02/03
----------------------

* Overall complexity
    - Best cases => Master theorem and/or Akra Bazzi method
        RF: O(n log^2 n)
        ETs: O(n log n)
    - Worst cases
        RF: O(log(H(n)))
        ETs: O(n^2)
    - Average case => Should still be good (see Quicksort average complexity)
      http://en.wikipedia.org/wiki/Quicksort
      Solve: T(n) = nlog(n) + 1/(n-1) \sum_{i=1}^{n-1} [T(i) + T(n-i)]
* Comparison of existing implementations
    - Experiments and/or implementation details


Part II: Interpreting random forests
====================================

(introduction)

5. Variables importances (NIPS)                                           23/03
------------------------

* Motivation
* Variable importances
    - as implemented
    - as derived from totally randomized trees
* Importances of relevant and irrelevant variables
* Generalization to other impurity measures
* Pruning and random subspaces
* Non-totally randomized trees (max_features > 1)
* Binary trees
* Illustration


6. Applications on real data                                              13/04
----------------------------

TODO
(Vincent, Cambridge)


Part III: Subsampling data
==========================

7. Random patches (ECML paper)                                            27/04
-----------------

* Motivation
    > Bias-variance discussion
    > Big(-ish) data
* Accuracy
* Memory usage


~~~


A. References
-------------


B. Notations
------------
